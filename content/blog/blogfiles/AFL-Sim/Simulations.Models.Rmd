---
title: "AFL Simulation Stimulation: Part 1"
author: "Joshua White"
date: "26 March 2019"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(readxl)
library(tidyverse)
library(purrr)

loc <- here()
setwd(loc)

#load data
HAinfo <- read_excel("HAinfo.xlsx", sheet = 4)
View(HAinfo)

names(HAinfo)[names(HAinfo) == 'Points'] <- 'For'

fixture2019 <- read_excel("HAinfo.xlsx", sheet = 5)
View(fixture2019)

#separate home and away and impute points against
Hpoints <- HAinfo[seq(1, nrow(HAinfo), 2),]
Apoints <- HAinfo[seq(2, nrow(HAinfo), 2),]
Hpoints$Against <- Apoints$For
Apoints$Against <- Hpoints$For

#join and make data tidy
points <- rbind(Hpoints, Apoints)
pointstidy <- points %>% gather("FororAgainst", "Points", -HorA, -Team)

#get mean points and sd thereof by team, H and A, and fororagainst
pointssummary <- pointstidy %>% group_by(HorA, Team, FororAgainst) %>%
                                summarise(sd = sd(Points), Points = mean(Points)) %>%
                                ungroup
pointssummary <- pointssummary[, c(2,1,3,4,5)]
pointssummary

#average H or A
Average <- pointssummary %>% group_by(HorA, FororAgainst) %>% summarise(Points = mean(Points)) 
Homeaveragefor <- as.numeric(Average[4, 3])
Homeaverageagainst <- as.numeric(Average[3, 3])
Awayaveragefor <- as.numeric(Average[2, 3])
Awayaverageagainst <- as.numeric(Average[1, 3])

#Strengths
# first we need to calculate the global averages for home and away scores both for and against
# (NB. the average home for score will be the same as the average away against score, and the average   #  home against score is the average away for score)
globalaverages <- pointssummary %>% group_by(HorA, FororAgainst) %>% summarise(Points = mean(Points)) 
Homeaveragefor <- as.numeric(globalaverages[4, 3])
Homeaverageagainst <- as.numeric(globalaverages[3, 3])
Awayaveragefor <- as.numeric(globalaverages[2, 3])
Awayaverageagainst <- as.numeric(globalaverages[1, 3])

#Now, lets create functions which implement the above formulas
AttackstrengthH <- function(T){
  as.numeric((pointssummary %>% 
                filter(Team == T, HorA == "H", FororAgainst == "For") %>%
                select(Points))/Homeaveragefor)
}

AttackstrengthA <- function(T){
  as.numeric((pointssummary %>% 
                filter(Team == T, HorA == "A", FororAgainst == "For") %>% 
                select(Points))/Awayaveragefor)
}
  
DefencestrengthH <- function(T){
  as.numeric(Homeaverageagainst/(pointssummary %>% 
                                   filter(Team == T, HorA == "H", FororAgainst == "Against") %>% 
                                   select(Points)))
}
  
DefencestrengthA <-function(T){
  as.numeric(Awayaverageagainst/(pointssummary %>% 
                                   filter(Team == T, HorA == "A", FororAgainst == "Against") %>%
                                   select(Points)))
}

#now let's get these strengths for all teams
  #create tibble to populate
strengths <- tibble(Team = unique(pointssummary$Team), AstrengthH = NA, 
                    AstrengthA = NA, DstrengthH = NA, DstrengthA = NA)

  # populate tibble with strengths
strengths$AstrengthH <- map_dbl(strengths$Team, AttackstrengthH)
strengths$AstrengthA <- map_dbl(strengths$Team, AttackstrengthA)
strengths$DstrengthH <- map_dbl(strengths$Team, DefencestrengthH)
strengths$DstrengthA <- map_dbl(strengths$Team, DefencestrengthA)
```

Recently I was, as I am (unfortunately) rather wont to do, aimlessly watching YouTube videos when I came across these [two](https://www.youtube.com/watch?v=Vv9wpQIGZDw) [videos](https://www.youtube.com/watch?v=Zs2M7gWSbTg) by Numberphile. Here, the authors discuss their attempts at modelling and simulating seasons of the English Premier League. 

As an avid [AFL](https://en.wikipedia.org/wiki/Australian_Football_League) fan, and with the upcoming season fast approaching (edit, now underway, [carn](https://www.urbandictionary.com/define.php?term=carn) [the cats!](https://www.afl.com.au/news/2019-03-22/match-report-collingwood-v-geelong)), why not try to apply these methods to the AFL season.  This post will be the first of a three part series. In part 1, I will discuss the models and compare their results to the actual data from the 2018 season. Part 2 will apply the models to the 2019 season. And part 3 will go through the details and show the code.  

## The Models

###Poisson Distributed Team Scores
Okay, lets discuss the model. Basically, each team's score in every game is modeled as a random drawing from a Poisson distribution --- i.e. $P(k) = e^{-\lambda} \frac{\lambda^k}{k!}$, where k is the number of points scored. A Poisson distribution is great for simple modelling because it only requires estimating one parameter, $\lambda$. On the other hand, it isn't exactly suited to the AFL context because the model assumes that all events (in this case, scoring a point) occur independently. In AFL, a goal in AFL is worth 6 points, violating this assumption.  

In any case, let's press on with that in mind. We calculate $\lambda$ for each game, based on the points scored for and against, at home and away, for each team in 2018:

$\lambda_{home team} =$ League Average points scored at home $\times$ home team attack strength at home $\times$ awayteam attack strength away

$\lambda_{away team} =$ League Average points scored away $\times$ away team attack strength away $\times$ hometeam defense strength at home

As you can see, the model takes into account the general home advantage as well as each particular team's attack and defensive strengths at home and away. The strength parameters refereed to above are simply the averages for that particular team, relative to the league-wide average. 

###Normally Distributed team scores
This model is a simple extension to the Poisson-based model above, and should be superior to it because: 

1. There is no assumption of independence, and 
2. It has an extra parameter to capture differences among teams in the variance of their defense and attack strength. 

Here, it is assumed that team scores are normally distributed around $\lambda$ as defined above, with a standard deviation calculated as the pooled standard deviation of that teams 'for' scores standard deviation, and the opponents 'against' scores standard deviation:
$$Points_{teamA} \sim \mathcal{N}(\mu=\lambda,\,\sigma = \sigma_p)\,$$ 
where: <br>
$$\sigma_{p}=\frac{\sigma_{teamAfor} + \sigma_{teamBagainst}}{2}$$

###Rankings model: tanh
This model simply relies on the ordinal data of last years final Ladder: Carlton, the wooden spoon winners (i.e. the last placeholders, out of 18 teams) get a ranking of 1, and Richmond, who finished on top of the table get a ranking of 18. Then, with this information, the probability of team A winning is modelled as follows:

$$P(A\>wins)=\frac{tanh(\frac{a-b}{w})+1}{2} - \frac{d}{2}$$
where,<br>
A = home team <br>
a = home team ranking <br> 
b = away team ranking <br>
w = weighting parameter (the higher the number the less weight placed on the rankings) <br>
x = draw rate, to allow for possibility of draws. 

This draw rate was based on the likelihood of drawing a game. Based on this data, which showed no increase likelihood of drawing based on similarity in rankings, is invariant to team rankings and is always set as $\frac{7}{990} \approx 0.007$ (which is the number of draws over the number of games in the last 5 years).

Finally, the probability of B winning is calculated as what remains as follows: 

$$P(B\>wins)= 1 - P(A\>wins) - \frac{d}{2}$$

So lets calculate the lambda for each home and away pairing that will occur in the AFL season 2019. Each of the 18 teams plays only 22 games, so each team does not get to play each other twice. 
Before we can calculate lambda we need to calculate the scaling parameters discussed above, what we will call attack strength (for home and away) and defencestrength (for home and away)


## The Data

```{r data}
pointstidy
fixture2019
```


##Results

###Poisson model


###Normal model


###Tanh model




OK, now lets get the data importing out of the way. For this model, there is only two bits of data I need: thescore data from each game played last year, and the fixtures for the upcoming season. I found the former from <https://afltables.com/afl/seas/2018.html>, and the latter from <https://en.wikipedia.org/wiki/2019_AFL_season#Premiership_season>. After a copy/paste job and some cleaning of the data (which is far too boring for this post). I got the following data in [tidy form](https://en.wikipedia.org/wiki/Tidy_data). 


Now the models we will use require us to have the mean points scored by each team, both home and away (for the Poisson distribution model), and the standard deviation thereof (for the normal distribution model). So lets quickly calculate that, and assign them variable names:

```{r points}
pointssummary <- pointstidy %>% group_by(HorA, Team, FororAgainst) %>%
                                summarise(sd = sd(Points), Points = mean(Points)) %>%
                                ungroup
pointssummary <- pointssummary[, c(2,1,3,4,5)]
pointssummary
```

### THe Model


```{r strengths, echo=FALSE}

# first we need to calculate the global averages for home and away scores both for and against
# (NB. the average home for score will be the same as the average away against score, and the average   #  home against score is the average away for score)
globalaverages <- pointssummary %>% group_by(HorA, FororAgainst) %>% summarise(Points = mean(Points)) 
Homeaveragefor <- as.numeric(globalaverages[4, 3])
Homeaverageagainst <- as.numeric(globalaverages[3, 3])
Awayaveragefor <- as.numeric(globalaverages[2, 3])
Awayaverageagainst <- as.numeric(globalaverages[1, 3])

#Now, lets create functions which implement the above formulas
AttackstrengthH <- function(T){
  as.numeric((pointssummary %>% 
                filter(Team == T, HorA == "H", FororAgainst == "For") %>%
                select(Points))/Homeaveragefor)
}

AttackstrengthA <- function(T){
  as.numeric((pointssummary %>% 
                filter(Team == T, HorA == "A", FororAgainst == "For") %>% 
                select(Points))/Awayaveragefor)
}
  
DefencestrengthH <- function(T){
  as.numeric(Homeaverageagainst/(pointssummary %>% 
                                   filter(Team == T, HorA == "H", FororAgainst == "Against") %>% 
                                   select(Points)))
}
  
DefencestrengthA <-function(T){
  as.numeric(Awayaverageagainst/(pointssummary %>% 
                                   filter(Team == T, HorA == "A", FororAgainst == "Against") %>%
                                   select(Points)))
}

#now let's get these strengths for all teams
  #create tibble to populate
strengths <- tibble(Team = unique(pointssummary$Team), AstrengthH = NA, 
                    AstrengthA = NA, DstrengthH = NA, DstrengthA = NA)

  # populate tibble with strengths
strengths$AstrengthH <- map_dbl(strengths$Team, AttackstrengthH)
strengths$AstrengthA <- map_dbl(strengths$Team, AttackstrengthA)
strengths$DstrengthH <- map_dbl(strengths$Team, DefencestrengthH)
strengths$DstrengthA <- map_dbl(strengths$Team, DefencestrengthA)
```

OK, now that we have the 'strength' values, let's use them to create the lambda values we need to run our simulations. 


###Simulating just one season

Now, to get to the cool part lets get simulating. First off, let's just figure out how to simulate just one season. Then, once we get past that we can get to the cool part of ONE MILLION SIMULATIONs. 

```{r one season, echo=FALSE}
# create League table (or Ladder as we call it here) to later populate
  Ladder <- tibble(Team = strengths$Team, W = 0, L = 0, D = 0, Pts = 0,
                      For = 0, Against = 0, Pct = 0)
  #simulate season.
for (i in 1:nrow(lambdas)) {

  
  #Here is the model working -- each score is simply a random drawing from a poisson distribution 
  # described by our calculated lambas
  homescore <- rpois(1, lambdas$homelambda[i])
  awayscore <- rpois(1, lambdas$awaylambda[i])
  hometeam <- lambdas$Hometeam[i]
  awayteam <- lambdas$Awayteam[i]
  
  #populate scores
  Ladder[Ladder$Team == hometeam,]$For <- Ladder[Ladder$Team == hometeam,]$For + homescore
  Ladder[Ladder$Team == hometeam,]$Against <- Ladder[Ladder$Team == hometeam,]$Against + awayscore 
  Ladder[Ladder$Team == awayteam,]$For <- Ladder[Ladder$Team == awayteam,]$For + awayscore
  Ladder[Ladder$Team == awayteam,]$Against <- Ladder[Ladder$Team == awayteam,]$Against + homescore
  
  #populate table for draw
  if (homescore == awayscore) {
    #hometeam changes
    Ladder[Ladder$Team == hometeam,]$D <- Ladder[Ladder$Team == hometeam,]$D + 1

    #awayteam changes
    Ladder[Ladder$Team == awayteam,]$D <- Ladder[Ladder$Team == awayteam,]$D + 1
    
  #populate table for hometeam win
  } else if (homescore > awayscore) {
    #hometeam changes
    Ladder[Ladder$Team == hometeam,]$W <- Ladder[Ladder$Team == hometeam,]$W + 1
    
    #awayteam changes
    Ladder[Ladder$Team == awayteam,]$L <- Ladder[Ladder$Team == awayteam,]$L + 1
    
  #populate for away team win
  } else {
    #hometeam changes
    Ladder[Ladder$Team == hometeam,]$L <- Ladder[Ladder$Team == hometeam,]$L + 1
    
    #awayteam changes
    Ladder[Ladder$Team == awayteam,]$W <- Ladder[Ladder$Team == awayteam,]$W + 1
  }
}

#calculate points (4 for win, 2 for draw) and percentage and order final table
#note that under AFL rules, if points are equal then ranked by percentage
Ladder$Pct <- Ladder$For / Ladder$Against * 100
Ladder$Pts <- (Ladder$W * 4) + (Ladder$D * 2)
FinalLadder <- Ladder %>% arrange(desc(Pts), desc(Pct))
FinalLadder
```

###ONE MILLION SEASONS

Okay now that we have checked that our simulation works. Lets do it a lot of times!

```{r simulation}

##### SIMULATIONS #####
Nsim <- 10

#set up simulation results table
SimResults <- matrix(data = 0, nrow = Nsim, ncol = 18)
colnames(SimResults) <- strengths$Team

#create Ladder for each season
Ladder <- tibble(Team = strengths$Team, W = 0, L = 0, D = 0, Pts = 0,
                 For = 0, Against = 0, Pct = 0)

for (i in 1:Nsim){
  
  #simulate each season.
  for (j in 1:nrow(lambdas)) {
    
    #Here is the model working -- each score is simply a random drawing 
    #from a poisson distribution described by our calculated lambas
    homescore <- rpois(1, lambdas$homelambda[j])
    awayscore <- rpois(1, lambdas$awaylambda[j])
    hometeam <- lambdas$Hometeam[j]
    awayteam <- lambdas$Awayteam[j]
    
    #populate scores
    Ladder[Ladder$Team == hometeam,]$For <- Ladder[Ladder$Team == hometeam,]$For + homescore
    Ladder[Ladder$Team == hometeam,]$Against <- Ladder[Ladder$Team == hometeam,]$Against + awayscore 
    Ladder[Ladder$Team == awayteam,]$For <- Ladder[Ladder$Team == awayteam,]$For + awayscore
    Ladder[Ladder$Team == awayteam,]$Against <- Ladder[Ladder$Team == awayteam,]$Against + homescore
    
    #populate table for draw
    if (homescore == awayscore) {
      #hometeam changes
      Ladder[Ladder$Team == hometeam,]$D <- Ladder[Ladder$Team == hometeam,]$D + 1
      
      #awayteam changes
      Ladder[Ladder$Team == awayteam,]$D <- Ladder[Ladder$Team == awayteam,]$D + 1

    #populate table for hometeam win
    } else if (homescore > awayscore) {
      #hometeam changes
      Ladder[Ladder$Team == hometeam,]$W <- Ladder[Ladder$Team == hometeam,]$W + 1
      
      #awayteam changes
      Ladder[Ladder$Team == awayteam,]$L <- Ladder[Ladder$Team == awayteam,]$L + 1
      
    #populate for away team win
    } else {
      #hometeam changes
      Ladder[Ladder$Team == hometeam,]$L <- Ladder[Ladder$Team == hometeam,]$L + 1
      
      #awayteam changes
      Ladder[Ladder$Team == awayteam,]$W <- Ladder[Ladder$Team == awayteam,]$W + 1
    }
    
  }
  
  #calculate points and percentage and order final table
  #note that under AFL rules, if points are equal then ranked by percentage
  Ladder$Pct <- Ladder$For / Ladder$Against * 100
  Ladder$Pts <- (Ladder$W * 4) + (Ladder$D * 2)
  FinalLadder <- Ladder %>% arrange(desc(Pts), desc(Pct))
  
  #populate simulation results table
    for (k in 1:nrow(FinalLadder)) {
      SimResults[i, FinalLadder$Team[k]] <- k
    }
} 

#Print and inspect results of Simulation
SimResultspois <- as_tibble(SimResults)
SimResultspois

Finalsimtable <- cbind.data.frame(MeanPos = colMeans(SimResults),
                                  MedianPos = apply(SimResults, 2, median),
                                  BestPos = apply(SimResults, 2, min),
                                  WorstPos = apply(SimResults, 2, max)) %>%
  cbind.data.frame(Team = strengths$Team)

Finalsimtablepois <- Finalsimtable[,c(5, 2, 1, 3, 4)] %>% arrange(MedianPos, MeanPos)
Finalsimtablepois

```


## normal distribution model 

So now for a slight variation to this model, we will add a standard deviation parameter, treat the lambda value as the mean, and assume that AFL scores will be normally distributed. A priori, I think this will give better results than the Poisson model for two principle reasons. 

  1. the assumptions of the Poisson model are not perfectly met in AFL. The model assumes that "The occurrence of one event does not affect the probability that a second event will occur. That is, events occur independently." In AFL this is not true as a goal is worth 6 points
  2. the normal model has a greater assumption to capture the variability of scores. 
  
So before we get to the simulations we need to make a few quick changes to the lambda tables to include sd values. 

```{r lambdasnorm}
#setup up dataframe for lambas, this time including standard deviations too
lambdas <- add_column(fixture2019, homelambda = NA, homesd = NA, awaylambda = NA, awaysd = NA)

#create lambda  and sd functions
lambdahometeam <- function(HomeTeam, AwayTeam) {
  Hometeamattackstrength <- as.numeric(strengths[strengths$Team == HomeTeam, "AstrengthH"])
  Awayteamdefencestrength <- as.numeric(strengths[strengths$Team == AwayTeam, "DstrengthA"])
  return(Homeaveragefor * Hometeamattackstrength / Awayteamdefencestrength)
}

lambdaawayteam <- function(AwayTeam, HomeTeam) {
  Awayteamattackstrength <- as.numeric(strengths[strengths$Team == AwayTeam, "AstrengthA"])
  Hometeamdefencestrength <- as.numeric(strengths[strengths$Team == HomeTeam, "DstrengthH"])
  return(Awayaveragefor * Awayteamattackstrength / Hometeamdefencestrength)
}

sdhometeam <- function(HomeTeam, AwayTeam) {
  Hometeamattack <- as.numeric(pointssummary %>% filter(Team == HomeTeam, HorA == "H", FororAgainst == "For") %>%
                    select(sd))
  Awayteamdefence <- as.numeric(pointssummary %>% filter(Team == AwayTeam, HorA == "A", FororAgainst == "Against") %>%
                    select(sd))
  # becuase n is equal can simply take average.
   return(mean(Hometeamattack, Awayteamdefence))
}

sdawayteam <- function(AwayTeam, HomeTeam) {
  Awayteamattack <- as.numeric(pointssummary %>% filter(Team == AwayTeam, HorA == "A", FororAgainst == "For") %>%
                                      select(sd))
  Hometeamdefence <- as.numeric(pointssummary %>%  filter(Team == HomeTeam, HorA == "H", FororAgainst == "Against") %>%
                                      select(sd))
# becuase n is equal can simply take average.
return(mean(Awayteamattack, Hometeamdefence))
}


#populate lamba values 
for (i in 1:nrow(lambdas)) {
  lambdas$homelambda[i] <- lambdahometeam(lambdas$Hometeam[i], lambdas$Awayteam[i])
  lambdas$awaylambda[i] <- lambdaawayteam(lambdas$Awayteam[i], lambdas$Hometeam[i])
  lambdas$homesd[i] <- sdhometeam(lambdas$Hometeam[i], lambdas$Awayteam[i])
  lambdas$awaysd[i] <- sdawayteam(lambdas$Awayteam[i], lambdas$Hometeam[i])
}

```

Okay now the grunt work is done lets do the simluations

```{r normsims}
Nsim <- 10

#set up simulation results table
SimResults <- matrix(data = 0, nrow = Nsim, ncol = 18)
colnames(SimResults) <- strengths$Team

for (i in 1:Nsim){

  #create Ladder for each season
  Ladder <- tibble(Team = strengths$Team, W = 0, L = 0, D = 0, Pts = 0,
                   For = 0, Against = 0, Pct = 0)
  
  #simulate each season.
  for (j in 1:nrow(lambdas)) {
    
    #Here is the model working -- each score is simply a random drawing 
    #from a normal dist characterised by our lambda as mean, and sd
    homescore <- rnorm(1, mean = lambdas$homelambda[j], sd = lambdas$homesd[j])
    awayscore <- rnorm(1, lambdas$awaylambda[j], sd = lambdas$homesd[j])
    hometeam <- lambdas$Hometeam[j]
    awayteam <- lambdas$Awayteam[j]
    
    #populate scores
    Ladder[Ladder$Team == hometeam,]$For <- Ladder[Ladder$Team == hometeam,]$For + homescore
    Ladder[Ladder$Team == hometeam,]$Against <- Ladder[Ladder$Team == hometeam,]$Against + awayscore 
    Ladder[Ladder$Team == awayteam,]$For <- Ladder[Ladder$Team == awayteam,]$For + awayscore
    Ladder[Ladder$Team == awayteam,]$Against <- Ladder[Ladder$Team == awayteam,]$Against + homescore
    
    #populate table for draw
    if (homescore == awayscore) {
      #hometeam changes
      Ladder[Ladder$Team == hometeam,]$D <- Ladder[Ladder$Team == hometeam,]$D + 1
      
      #awayteam changes
      Ladder[Ladder$Team == awayteam,]$D <- Ladder[Ladder$Team == awayteam,]$D + 1
      
      #populate table for hometeam win
    } else if (homescore > awayscore) {
      #hometeam changes
      Ladder[Ladder$Team == hometeam,]$W <- Ladder[Ladder$Team == hometeam,]$W + 1
      
      #awayteam changes
      Ladder[Ladder$Team == awayteam,]$L <- Ladder[Ladder$Team == awayteam,]$L + 1
      
      #populate for away team win
    } else {
      #hometeam changes
      Ladder[Ladder$Team == hometeam,]$L <- Ladder[Ladder$Team == hometeam,]$L + 1
      
      #awayteam changes
      Ladder[Ladder$Team == awayteam,]$W <- Ladder[Ladder$Team == awayteam,]$W + 1
    }
    
  }
  
  #calculate points and percentage and order final table
  #note that under AFL rules, if points are equal then ranked by percentage
  Ladder$Pct <- Ladder$For / Ladder$Against * 100
  Ladder$Pts <- (Ladder$W * 4) + (Ladder$D * 2)
  FinalLadder <- Ladder %>% arrange(desc(Pts), desc(Pct))
  
  #populate simulation results table
  for (k in 1:nrow(FinalLadder)) {
    SimResults[i, FinalLadder$Team[k]] <- k
  }
} 

#Print and inspect results of Simulation
SimResultsnorm <- as_tibble(SimResults)
SimResultsnorm

Finalsimtable <- cbind.data.frame(MeanPos = colMeans(SimResults),
                                  MedianPos = apply(SimResults, 2, median),
                                  BestPos = apply(SimResults, 2, min),
                                  WorstPos = apply(SimResults, 2, max)) %>%
                 cbind.data.frame(Team = strengths$Team)

Finalsimtablenorm <- Finalsimtable[,c(5, 2, 1, 3, 4)] %>% arrange(MedianPos, MeanPos)
Finalsimtablenorm
```